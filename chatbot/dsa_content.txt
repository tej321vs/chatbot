
Data Structures and Algorithms (DSA) - Core Concepts

1. Arrays:
- A linear collection of elements stored in contiguous memory.
- Access via index (O(1)), but insertion/deletion is expensive (O(n)).
- Example: int arr[5] = {1, 2, 3, 4, 5};

2. Linked Lists:
- Elements (nodes) contain data and pointer to the next node.
- Efficient insertion/deletion (O(1) at head), but slower access (O(n)).
- Types: Singly, Doubly, Circular.

3. Stacks:
- LIFO (Last In First Out) structure.
- Supports push() and pop() operations.
- Example: Backtracking, undo operations.

4. Queues:
- FIFO (First In First Out) structure.
- Operations: enqueue() and dequeue().
- Types: Circular Queue, Priority Queue, Deque.
- Example: Scheduling, buffers.

5. Trees:
- Hierarchical structure with root and child nodes.
- Binary Tree: Each node has max 2 children.
- Binary Search Tree (BST): Left < root < Right.
- Traversals: Inorder, Preorder, Postorder.

6. Graphs:
- Set of nodes (vertices) and edges.
- Types: Directed, Undirected, Weighted.
- Representations: Adjacency List, Matrix.
- Traversals: BFS (Breadth First), DFS (Depth First).

7. Searching Algorithms:
- Linear Search: O(n), checks each element.
- Binary Search: O(log n), requires sorted array.

8. Sorting Algorithms:
- Bubble Sort: O(n^2), simple but slow.
- Selection Sort, Insertion Sort: O(n^2)
- Merge Sort: O(n log n), divide-and-conquer.
- Quick Sort: O(n log n) avg, O(n^2) worst.
- Heap Sort: Uses heap, O(n log n).

9. Recursion:
- Function calls itself to solve subproblems.
- Requires base condition to stop.
- Example: Factorial, Fibonacci, Tree traversals.

10. Dynamic Programming (DP):
- Solves problems by breaking into subproblems.
- Stores results of subproblems to avoid recomputation (memoization).
- Examples: Knapsack, Fibonacci, Longest Common Subsequence.
